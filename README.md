### Prerequisites (Your own machine)
This playground uses the following technology so you will need to check they are installed:

-   VS Code
-   Python Extension for VSCode
-   Terminal (We use Bash)
-   Python
-   Flask
-   Pytest
-   Some knowledge of basic unit testing
-   Some knowledge of programming fundamenals

# Introduction
Test Driven Development is a software development methodology where tests are written before application code is written.
The idea is that a developer will think about how the user will use the application/components through the process of writing
tests that validate the operation.

In this playground we are going to build a web application in python and Flask via the TDD process.
We will write tests to describe the functionality of the components.

# set up your environment

### Opening the Next.js application in VS Code

### Step 1
To get the environment prepared for the event you will need your meetup username.

You can find while logged in at [meetup.com](https://meetup.com) as in the example below

<p align="center">
<img width="544" alt="Screenshot 2023-05-23 at 11 33 12" src="./zz_assets/meetup.png">
</p>

Copy the username, in the above example it is `DevOps Playground`, and go to  [lab.devopsplayground.org](https://lab.devopsplayground.org/) and paste your username to the form like in the example below


<p align="center">
<img width="544" alt="Screenshot 2023-05-23 at 11 33 12" src="./zz_assets/lab.png">
</p>

### Step 2

Copy the IDE link

Open a new tab and paste that link into the address bar of the new tab. 

You should be presented with VS Code which should look something like this:


### Step 3
Make sure you have the python extension installed in .vscode which is automatically generated by the IDE.

We will be using the Testing toolbar in vscode. For this project you will need to manually change the .vscode that is auto generated by your IDE.
<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/settings.png">
</p>

in the settings.json, replace the contents "python.testing.pytestArgs" with:

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/ide_view.png">
</p>


```
"python.testing.pytestArgs": [
        "project/tdd_stock/test"
    ],
```

### 4
In project/tdd_stock/test click on test_unit.py.
This should activate the test tool bar in the IDE on the left (you may need to restart the browser)
When you click on the test tool bar you should be able to see the test tree.

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/test_tree.png">
</p>


# Code base

App: the application directory where the flask application will be in

- app.py: the main flask application with the routes
- __init__.py : initialisation file for python.
- components.py: file containing helper functions for app.py
- models.py: contains the Stock class which defines the model for a stock

db: database file for our application

- stock_db.json: the database file containing stocks based off the Stock model.
This file will act as our database for our application

test: Directory for tests and tes resources

- __init__.py : initialisation file for python.
- test_data/stock_test.json: a test stock object that will be used in our tests
- notes.txt: notes contianing curl commands for manual testing
- test_int.py: integration tests will be written here
- test_unit.py: unit tests will be written here

# The Playground

### Step 1

We want to implement a feature where we can get all the stocks from the database as a list of stock objects.

Go to project/tdd_stock/test/test_unit.py. You will see test_get_all_stocks as the first test.

```

    def test_get_all_stocks_returns_all(self):
        stocks = get_all_stocks()

```

This test has not been fully implemented. So far it calls the get_all_stocks function but there are no assertions. Lets add a simple assertion to get us started.
We know that the database file has 3 stock objects. As a simple assertion we can check that when we get all stocks the list should be a length of 3.
Add this assertion to the test function

```python

    def test_get_all_stocks_returns_all(self):
        stocks = get_all_stocks()
        
        assert len(stocks) == 3

```

If you run the test it will fail

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/get_all_stocks_initial_error.png">
</p>

Unsuprisingly, this is because the test function has no visibility of get_all_stocks. Since a stub function is already present in components.py, lets import it at the top of the test file. You can put it underneath the Stock model import

```python

from app.models import Stock
from app.components import get_all_stocks

```
If you rerun the test you now get this error:

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/get_all_stocks_len_error.png">
</p>

We have now reached the "red" stage of the red, green, refactor TDD flow. We can fix this error by now implementing some application code to make the test pass.

### Step 2

Go to app/components.py and see the get_all_stocks_function

```python
def get_all_stocks():

    with open('project/tdd_stock/db/stock_db.json') as dbfile:
        stocks_json = json.load(dbfile)
```

The function so far reads the db file and loads it into a json list using pythons json library.
Since the DB file is in the form of a json list, json.load will produce a list.
Lets return the list

```python
def get_all_stocks():

    with open('project/tdd_stock/db/stock_db.json') as dbfile:
        stocks_json = json.load(dbfile)

    return stocks_json
```

The test will now pass, the "Green" stage in TDD.

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/get_all_stocks_test_pass_initial.png">
</p>

### Step 3

Now that we have a passing test lets go into the "Refactor" stage of TDDs red, green, refactor. Part of the requirement for this component is that a list of stock objects is returned. Our test so far only checks the length of the list. Lets add an assertion to prove that we ge back a list of stocks.

Go to project/tdd_stock/test/test_unit.py

```python
    def test_get_all_stocks_returns_all(self):
        stocks = get_all_stocks()
        assert len(stocks) ==3
        assert stocks[0].analyst == 'warren.buffet'
```
 By invoking the analyst variable we are proving that the first element in the list is a Stock object that has the attribute 'analyst'

 After rerunning the test you should get an error like:

```python
 Failed: [undefined]AttributeError: 'dict' object has no attribute 'analyst'
```
This is because get_all_stocks so far only returns a list of pythin dicitionaries, not a list of Stocks. Lets refactor our function to support that.

Go to project/tdd_stock/app/components.py. Update the function with a lambda expression that will iterate through the list of dictioanries and convert them
to Stock objects

```python
def get_all_stocks():

    with open('project/tdd_stock/db/stock_db.json') as dbfile:
        stocks_json = json.load(dbfile)

    stocks_list_obj = list(map(lambda x: Stock(**x), stocks_json))

    return stocks_list_obj
```

The test will now pass once rerun.

### Step 4

We have implemented a function, now lets use it in our app.py and associate it with a route. We want the route to return our json dictionary.

Go to app/app.py uncomment the function with the rout '@app.route("/stock/all_stocks/", methods=["GET"])'

```python
    @app.route("/stock/all_stocks/", methods=["GET"])
    def get_all():
        stocks = get_all_stocks()
        return jsonify([vars(e) for e in stocks])
```

We can run this integration test by going to the test tree

<p align="center">
<img width="668" alt="Screenshot 2023-05-23 at 10 06 27" src="https://github.com/cgungaloo/tdd_stock/blob/master/readme_resources/get_all_stock_integration_tree.png">
</p>

Running this will give the same error as the unit test 'Failed: [undefined]NameError: name 'get_all_stocks' is not defined' we can fix this by doing an import in

in app/app.py add the import

```python
from app.components import get_all_stocks
```

The test will now pass.

In this test we are asserting that we get a 200 response code from the endpoint. We can add a another assertion by checking the length of the response.

in project/tdd_stock/test/test_int.py add to the test_get_all_stocks

```python
    def test_get_all_stocks(self):
        response = self.client.get("/stock/all_stocks/")

        assert response.status_code == 200
        stock_json = response.json
        assert len(stock_json) == 3
```

If you want you can add some more assertions too.

We have now implemented a function and a route via TDD!

### Step 5

Lets implement the next function, get_stock_by_ticker.

Go to project/tdd_stock/test/test_unit.py

uncomment the function 'def test_get_stock_by_ticker_returns_correct_stock(self):'

```python
    def test_get_stock_by_ticker_returns_correct_stock(self):
        pass
```

this function will return a single stock object when a ticker symbol is passed as a string.
Lets implement the test to define how the application function will work.

```python
    def test_get_stock_by_ticker_returns_correct_stock(self):
        
        stock = get_stock_by_ticker('MSFT')

        assert stock.ticker_symbol == 'MSFT'
        assert stock.name == 'Microsoft'

```

lets also import get_stock_by_ticker

```python
from app.components import get_all_stocks, get_stock_by_ticker
```
We have now defined a test that we can implement against.

If you run the test now, you will get: 'test_get_stock_by_ticker_returns_correct_stock Failed: [undefined]AttributeError: 'NoneType' object has no attribute 'ticker''

Lets make this test go green. In project/tdd_stock/app/components.py our function looks like:

```python
def get_stock_by_ticker(ticker_symbol):
    with open('project/tdd_stock/db/stock_db.json') as dbfile:
        stocks_json = json.load(dbfile)
        
    pass
```

We need to read the stocks and find the one that matches the ticker symbol. We will use a filter function to find the stock we want

```python

def get_stock_by_ticker(ticker_symbol):
    with open('project/tdd_stock/db/stock_db.json') as dbfile:
        stocks_json = json.load(dbfile)

    stocks_list_obj = list(map(lambda x: Stock(**x), stocks_json))

    stock_list_match = list(filter(lambda x:x.ticker_symbol == ticker_symbol, stocks_list_obj))

    return stock_list_match[0]

```

After rerunning the test, it will pass.

You may notice that some of the code has been repeated from get_all_stocks. We can now do a refactor to make th function abit simpler by calling get_all_stocks

```python
def get_stock_by_ticker(ticker_symbol):
    stocks_list_obj = get_all_stocks()

    stock_list_match = list(filter(lambda x:x.ticker_symbol == ticker_symbol, stocks_list_obj))

    return stock_list_match[0]
```

We have reduced the code by using the get_all_stocks function implemented earlier.
If you re run all the tests that we have written so far, they should all still pass.

### Step 6

Lets now use get_stock_by_ticker in app/app.py

uncomment the function with the route '@app.route("/stock/<ticker_symbol>/",methods=["GET"])'

```python
@app.route("/stock/<ticker_symbol>/",methods=["GET"])
def get_stock_by_ticker_symbol(ticker_symbol):
    
    # if stock:
    return jsonify(stock.__dict__)
    # else:
    #     return jsonify(None)

```

in project/tdd_stock/test/test_int.py uncomment 'test_get_stock_by_ticker_integration'

This test has been implemented, but if you run it, it will fail: 'test_get_stock_by_ticker_integration Failed: [undefined]NameError: name 'stock' is not defined'

Lets make the test pass by fixing the app function.
The function fails because stock is undefined. In app/app.py you can see that get_stock_by_ticker is not being called. Lets call it.

```python
@app.route("/stock/<ticker_symbol>/",methods=["GET"])
def get_stock_by_ticker_symbol(ticker_symbol):
    
    stock = get_stock_by_ticker(ticker_symbol)
    # if stock:
    return jsonify(stock.__dict__)
    # else:
    #     return jsonify(None)

```

Make sure you import get_stock_by_ticker

```python
from app.components import get_all_stocks, get_stock_by_ticker

```

The commented if statement will be used later in other functionality.
The tests will now pass.

### Step 7

What if a ticker_symbol we provide is not found in the DB? Lets write a test to describe what the expected behaviour should be

uncomment 'test_invalid_stock_not_found' in project/tdd_stock/test/test_unit.py

```python
    def test_invalid_stock_not_found(self):
        stock = get_stock_by_ticker("TSLA")
        assert stock == None
```

This test checks that is we pass an invaldi ticker symbol we get None returned.
This test when run, fails.

```python
Failed: [undefined]IndexError: list index out of range
self = <test.test_unit.StockTestClass testMethod=test_invalid_stock_not_found>
```

Lets make this test green by fixing the function under test, get_stock_by_ticker

```python
def get_stock_by_ticker(ticker_symbol):
    stocks_list_obj = get_all_stocks()
    
    stock_list_match = list(filter(lambda x:x.ticker_symbol == ticker_symbol, stocks_list_obj))

    if len(stock_list_match) ==0:
        return None
    return stock_list_match[0]
```

The test now passes

### Step 8

The next requirement is to add a stock to the DB. Lets think about how to test that.

Go to test/test_unit.py

uncomment test_save_stock_success

```python
    def test_save_stock_success(self):

    with open('project/tdd_stock/db/stock_db.json) as f:
        stock_data = json.load(f)
```

You'll notice that there is a reference to 'project/tdd_stock/db/stock_db.json' this is a test file which contains a stock object. We will use this to update the db.

We can know if save_stock works by shceking the state of the DB after upload. if we call get_all_stocks after save_stock, we expect the lentgh of the DB to now be 4.

Update the test

```python
    def test_save_stock_success(self):

        with open('project/tdd_stock/test/test_data/stock_test.json') as f:
            stock_data = json.load(f)

        save_stock(stock_data)

        stocks = get_all_stocks()

        assert len(stocks) == 4
```

and import save_stock

```python
from app.components import get_all_stocks, get_stock_by_ticker, save_stock
```

in project/tdd_stock/app/components.py uncomment save_stock

```python
def save_stock(stock_to_save):
    with open('project/tdd_stock/db/stock_db.json','r') as json_db:
        stock_list = json.load(json_db)
    # stock_list_obj = list(map(lambda x:Stock(**x), stock_list))
    # stock_obj = Stock(**stock_to_save)
    # stock_list_obj.append(stock_obj)

    stock_list_json = list(map(lambda x: vars(x), stock_list_obj))
    with open('db/stock_db.json','w') as json_db:
        json.dump(stock_list_json,json_db,sort_keys=True, indent=4, separators=(',', ': '))
    # else:
    #     raise Exception(f"{stock_obj.ticker_symbol} already exists")
```

Running the test gives this error: 'test_save_stock_success Failed: [undefined]TypeError: app.models.Stock() argument after ** must be a mapping, not list'

We are now at Red stage in Red, Green, Refactor. Lets pass the test.
We need to get all stocks and convert it to a list of stocks. We then take the incoming stock and add it to the list. We then rewrite the updated list to the DB

uncomment the code that does this

```python
def save_stock(stock_to_save):
    with open('project/tdd_stock/db/stock_db.json','r') as json_db:
        stock_list = json.load(json_db)
    stock_list_obj = list(map(lambda x:Stock(**x), stock_list))

    stock_obj = Stock(**stock_to_save)
    stock_list_obj.append(stock_obj)

    stock_list_json = list(map(lambda x: vars(x), stock_list_obj))
    with open('project/tdd_stock/db/stock_db.json','w') as json_db:
        json.dump(stock_list_json,json_db,sort_keys=True, indent=4, separators=(',', ': '))
    # else:
    #     raise Exception(f"{stock_obj.ticker_symbol} already exists")
```

The test should now pass. We can now add a further assertion to check that the new stock is added.

```python
    def test_save_stock_success(self):

        with open('project/tdd_stock/test/test_data/stock_test.json') as f:
            stock_data = json.load(f)

        save_stock(stock_data)

        stocks = get_all_stocks()

        assert len(stocks) == 4
        assert stocks[3].ticker_symbol == 'HTHIY'
```

This proves that the last entry in the DB was stock from the test data.
If you go to the DB file, you'll notice that you can't see the new stock in the file. This is because the unit test has a teadDown function that automatically removes the entry after the test. This allows you to run the test repeatedly without it growing the DB. This will become important when we implement a duplication check later

### Step 9

Lets now use this function in a route.

Go to project/tdd_stock/test/test_int.py. Uncomment test_add_stock_integration

```python
    def test_add_stock_integration(self):

        with open('test/test_data/stock_test.json') as f:
            stock_data = json.load(f)

        data_json = json.dumps(stock_data)
```

At a route level we want to check that the function returns a 200 response when we call the endpoint.
Uncomment @app.route("/add-stock/",methods=["POST"]) in app/app.py

```python
@app.route("/add-stock/",methods=["POST"])
def add_stock_to_db():
    # try catch for error
    # try:
    save_stock(request.json)
    resp = jsonify(success=True)
    return resp
    # except Exception as e:
    #     return Response(f'{str(e)}',status=400)
```

Import the function too

```python
from app.components import get_all_stocks, get_stock_by_ticker, save_stock

```
